var documenterSearchIndex = {"docs":
[{"location":"examples/branching-oup/#Branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"The Ornstein-Uhlenbeck process (OUP) is defined by the stochastic differential equation\n\ndX_t = alpha (mu -  X_t)dt + sigma dW_t\n\nand describes a variable X_t which fluctuates stochastically around its average or steady-state value mu; alpha0 is the rate at which fluctuations return to their steady-state value, sigma0 defines the relative magnitude of the stochastic fluctuations, and W_t is the Wiener process.\n\nIf X_t represents the expression level of a gene, then the OUP is the simplest model of stochastic gene expression. The branching OUP can then be used to model the evolution of gene expression during cell proliferation.[1] At the opposite end of biological time scales, the branching OUP is also used as a model for the evolution of traits under selection in a phylogenetic tree.[2]\n\n[1]: To be precise, during proliferation, cells first double in size and then divide in two daughter cells half the size. If we don't explicitly model this doubling-halving cycle, X_t represents a concentration rather than a absolute level.\n\n[2]: See Hansen (1997) or these and other lectures by Paul Bastide.","category":"section"},{"location":"examples/branching-oup/#Setting-up-the-problem","page":"Branching Ornstein-Uhlenbeck process","title":"Setting up the problem","text":"Similar to the branching Brownian motion tutorial, we cannot (yet) use the distributionally exact OUP implementation from the DiffEqNoiseProcess package, but must define the OUP as a SDEProblem:\n\nusing DifferentialEquations\nf(u,p,t) = p[2]*(p[1]-u)\ng(u,p,t) = p[3]\nu0 = 0.0\ntspan = (0.0, 5.0)\nμ = 2.0\nα = 5.0\nσ = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\n\nWe can first verify that after an initial \"burn-in\" period, the OUP indeed fluctuates around its steady-state value mu:\n\nusing Plots\nsol = solve(oup, EM(), dt=0.01)\nplot(sol; linewidth=2, legend=false)\n\nWe can now set up the branching OUP problem in the same way as in the branching Brownian motion tutorial:\n\nusing BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nboup = ConstantRateBranchingProblem(oup, λ, nchild)","category":"section"},{"location":"examples/branching-oup/#Sampling-a-trajectory","page":"Branching Ornstein-Uhlenbeck process","title":"Sampling a trajectory","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:\n\nusing Random\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01);\nplot(sol; linewidth=2, branchpoints=true)\n\nWe observe that after a few generations, all cells fluctuate around their steady state value mu=20.","category":"section"},{"location":"examples/branching-oup/#Memory-in-the-branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Memory in the branching Ornstein-Uhlenbeck process","text":"The dynamics of the branching OUP is driven by two parallel processes, the return to steady-state with rate alpha and the branching with rate lambda. If the half-life ln 2alpha of the stochastic fluctuations is short compared to the average lifetime 1lambda of a cell, each cell has sufficient time to equilibrate and the population as a whole will be distributed around the steady-state value, as in the figure above.\n\nHowever, if the half-life of the stochastic fluctuations is long compared to the average lifetime of a cell, large fluctuations early in the expansion can have a long-lasting effect on the population as a whole. This is the memory phenomenon referred to in the BranchingProcesses package introduction. For the branching OUP specifically, this phenomenon has been analyzed in great mathematical detail.\n\nTo illustrate this phenomenon, we set the same random seed as above (to ensure exactly the same branching times) and only change the value of alpha:\n\nα = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01)\nplot(sol; linewidth=2, branchpoints=true)\n\nWe observe that the system now did not have sufficient time to equilibrate within the typical life-time of a cell, and the population as a whole is shifted towards, that is, remembers, its initial state.\n\nThat the memory is due to the slow return to steady-state of the fluctuations and not the value of the initial state can be seen by starting the same problem in the steady state itself:\n\nα = 0.5\nu0 = μ\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01)\nplot(sol; linewidth=2, branchpoints=true)\n\nAgain we observe a shifted distribution due to large fluctuations early in the expansion.","category":"section"},{"location":"examples/tree-reduction/#Tree-reduction","page":"Tree reduction","title":"Tree reduction","text":"In experiments it is often the case that a single measurement (per variable) is obtained for a clone that is grown for set time or number of generations from a single cell. For instance in the MemorySeq paper, total RNA counts were obtained for each clone. In the BranchingProcesses package this can be easily simulated by applying a function to (for instance summing) the Values at the tips of a branching process. However in simulations we may want to do a bit more and obtain the entire time series of a summary statistic from a BranchingProcessSolution. This can be done with the reduce_tree function.","category":"section"},{"location":"examples/tree-reduction/#Setting-up-the-problem-and-sampling-a-tree","page":"Tree reduction","title":"Setting up the problem and sampling a tree","text":"Start by creating a branching birth-death process. First define the single-cell process,\n\nusing Catalyst\nrn = @reaction_network begin\n    kp, 0 --> X\n    kd, X --> 0\nend\n\nusing DifferentialEquations, JumpProcesses\nu0 = [200]\ntspan = (0.0, 3.0)\np = [:kp => 50.0, :kd => 0.25]\njinput = JumpInputs(rn, u0, tspan, p)\njprob = JumpProblem(jinput)\n\nand then the branching process,\n\nusing BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nnothing # hide\n\nSample and plot a tree:\n\nusing Random # hide\nRandom.seed!(123) # hide\nusing Plots, LaTeXStrings\nsol = solve(bjprob,  SSAStepper());\nplot(sol; linewidth=2, branchpoints=true)","category":"section"},{"location":"examples/tree-reduction/#Obtaining-a-reduced-time-series","page":"Tree reduction","title":"Obtaining a reduced time series","text":"By default, reduce_tree sums the values of all cells alive at a given time, starting from the initial time of the root cell and stopping at the final time of the last living cell, with a time step of dt:\n\nsol_red = reduce_tree(sol; dt=0.01);\nnothing # hide\n\nThe reduced time series has the type ReducedBranchingProcessSolution and a plot recipe is available for this type:\n\nplot(sol_red)\n\nIt is possible to replace the default summing of values to taking a product, although use cases for this in practice may be rather limited:\n\nreduce_tree(sol; dt=0.01, reduction=\"prod\");\nnothing # hide","category":"section"},{"location":"examples/tree-reduction/#Applying-transformations","page":"Tree reduction","title":"Applying transformations","text":"We can apply a transformation to the values of the process before summing. For instance, to sum the squared values:\n\nsol_red = reduce_tree(sol; dt=0.01, transform=(x -> x.^2));\nplot(sol_red)\n\nor to count the number of cells alive at any given time:\n\nsol_red = reduce_tree(sol; dt=0.01, transform=(x -> 1));\nplot(sol_red)","category":"section"},{"location":"examples/tree-reduction/#Reducing-and-transforming-multivariable-processes","page":"Tree reduction","title":"Reducing and transforming multivariable processes","text":"The default for reducing multivariable processes is to sum all variables separately. Let's recreate the multivariable branching process example:\n\nmm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\nu0 = [:S => 30, :E => 10, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)\nλ = 0.05\nnchild = 2\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nRandom.seed!(123) # hide\nsol = solve(bjprob,  SSAStepper());\nnothing # hide\n\nObtain a reduced time series for the sum of all variables:\n\nvar_names = string.(unknowns(mm_system))\nsol_red = reduce_tree(sol; dt=0.1);\nplot(sol_red)\n\nTo summarize only one or a subset of variables, we can either use an idxs keyword argument:\n\nsubs = [1,4]\nsol_red = reduce_tree(sol; dt=0.1, idxs=subs);\nplot(sol_red)\n\nor use a transformation:\n\nsol_red = reduce_tree(sol; dt=0.1, transform=(x -> x[subs]));\nplot(sol_red);\n\nTransformations can also be used to create summaries of summaries, for instance, for the total number of molecules:\n\nsol_red = reduce_tree(sol; dt=0.1, transform=(x -> sum(x)));\nplot(sol_red)","category":"section"},{"location":"examples/tree-reduction/#Tree-reduction-and-ensemble-simulations","page":"Tree reduction","title":"Tree reduction and ensemble simulations","text":"Tree reduction is particularly useful in the context of ensemble simulations.\n\nensemble_bjprob = EnsembleProblem(bjprob)\nensemble_tree = solve(ensemble_bjprob, SSAStepper(), EnsembleThreads(), trajectories=100)","category":"section"},{"location":"examples/branching-birth-death/#Branching-birth-death-processes","page":"Branching birth-death process","title":"Branching birth-death processes","text":"In the branching Ornstein-Uhlenbeck process example, we considered the Ornstein-Uhlenbeck process (OUP) as a simple model for stochastically fluctuating gene expression. However, gene expression is modelled more realistically as a process taking discrete values representing molecule counts.\n\nIf we assume molecules are produced and degraded one at a time, we obtain a birth-death process. Such processes, and many other more complicated processes, are most easily defined using the Catalyst reaction network modelling language.","category":"section"},{"location":"examples/branching-birth-death/#Setting-up-the-problem","page":"Branching birth-death process","title":"Setting up the problem","text":"We first define the single-particle, in our case single-cell, dynamics as a reaction network:\n\nusing Catalyst\nrn = @reaction_network begin\n    kp, 0 --> X\n    kd, X --> 0\nend\n\nwhere kp and kd are the parameters of the model, respectively the production and degradation rates.\n\nAs explained in the Catalyst tutorials, we can define a JumpProcess to simulate this reaction network as follows:\n\nusing DifferentialEquations, JumpProcesses\nu0 = [200]\ntspan = (0.0, 3.0)\np = [:kp => 50.0, :kd => 0.25]\njinput = JumpInputs(rn, u0, tspan, p)\njprob = JumpProblem(jinput)\n\nA trajectory for a single cell can be sampled and plotted:\n\nusing Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)\n\nA branching jump problem is set up as in the branching Brownian motion and branching Ornstein-Uhlenbeck process examples:\n\nusing BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nnothing # hide","category":"section"},{"location":"examples/branching-birth-death/#Sampling-a-trajectory","page":"Branching birth-death process","title":"Sampling a trajectory","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:\n\nusing Random # hide\nRandom.seed!(123) # hide\nsol = solve(bjprob,  SSAStepper());\nplot(sol; linewidth=2, branchpoints=true)","category":"section"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(bp::T, alg::A; kwargs...) where {T<:ConstantRateBranchingProblem, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nSolve a branching stochastic process with constant branching rate defined by the ConstantRateBranchingProblem bp. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample trajectories of the underlying SDE problem.\n\nReturns a BranchingProcessSolution containing the problem definition and the resulting tree structure.\n\nSee also: ConstantRateBranchingProblem, solve_and_split, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.solve_and_split","page":"Solvers","title":"BranchingProcesses.solve_and_split","text":"solve_and_split(prob::T, lifetime::L, nchild::O, alg::A; kwargs...) where {T<:SciMLBase.AbstractDEProblem, L<:UnivariateDistribution, O<:Union{Integer,DiscreteUnivariateDistribution}, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nRecursively solve a branching stochastic process where the single-particle dynamics is defined by the SDE problem prob, the lifetime distribution is lifetime, and the number of children nchild of each particle is either a non-negative integer or a discrete distribution from which the number of children is sampled. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample the trajectory of each particle.\n\nThe timespan of the problem prob defines the total time interval for the branching process. A lifetime for the first particle is sampled from the provided lifetime distribution. If the lifetime is larger than the total time interval, the problem is solved until the end of the original interval and a solution node is returned without children. If the lifetime is smaller than the total time interval, the problem is solved until the sampled lifetime, and a solution node is returned with recursively solved children for the remaining time interval.\n\nReturns a BranchingProcessNode representing the tree structure.\n\nSee also: SDE problems, sample_lifetime, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_lifetime","page":"Solvers","title":"BranchingProcesses.sample_lifetime","text":"sample_lifetime(lifetime::T) where T <: UnivariateDistribution\n\nSample the lifetime of a particle from the provided lifetime distribution. This function draws a random sample from the given distribution.\n\nFor backward compatibility, when a ConstantRateBranchingProblem is constructed with a positive real number λ as the second argument, it is interpreted as a branch rate and converted to an exponential distribution with parameter 1/λ.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_offspring","page":"Solvers","title":"BranchingProcesses.sample_offspring","text":"sample_offspring(nchild::O) where O<:Union{Integer,DiscreteUnivariateDistribution}\n\nSample the number of offspring for a particle. If the input nchild is an integer, that integer is returned. If nchild is a discrete distribution, a sample from that distribution is returned.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.remake_initial_condition","page":"Solvers","title":"BranchingProcesses.remake_initial_condition","text":"remake_initial_condition(prob::P, tspan, u0=nothing) where P<:SciMLBase.AbstractDEProblem\n\nRemake the problem prob with a new timespan tspan and, optionally, a new initial condition u0. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.get_timespan","page":"Solvers","title":"BranchingProcesses.get_timespan","text":"get_timespan(prob::P) where P<:SciMLBase.AbstractDEProblem\n\nGet the timespan of the problem prob. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\nget_timespan(tree::BranchingProcessSolution)\n\nGet the timespan of a BranchingProcessSolution tree, defined as the time from the initial time of the root to the latest final time of any of the leaves.\n\n\n\n\n\n","category":"function"},{"location":"examples/multi-variable-processes/#Multi-variable-branching-stochastic-processes","page":"Multi-variable branching processes","title":"Multi-variable branching stochastic processes","text":"The single-particle or single-cell stochastic process undergoing branching can be a multi-variable process. To illustrate this, consider the example of Michaelis-Menten enzyme kinetics, where an enzyme (E) transforms a substrate (S) into a product (P). The reaction network is defined in the Catalyst library of basic chemical reaction network models:\n\nusing Catalyst\nmm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\nWe set up a single-cell process (with four variables, S. E. SE. and P) as in the model library:\n\nusing DifferentialEquations, JumpProcesses\nu0 = [:S => 30, :E => 10, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\n\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)\n\nA trajectory for a single cell can be sampled and plotted:\n\nusing Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)\n\nA branching jump problem is set up as usual:\n\nusing BranchingProcesses\nλ = 0.05         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nnothing # hide\n\nTo sample a tranjectory of the branching process, we call the solve function as usual:\n\nusing Random # hide\nRandom.seed!(123) # hide\nusing AbstractTrees\ntree = solve(bjprob,  SSAStepper());\ntreeheight(tree)\n\nIf we plot the solution, by default the trajectory for the first variable is shown:\n\nplot(tree; branchpoints=true)\n\nBecause the plot recipe piggybacks on the plot recipe for differential equation solutions, variables for plotting can be chose in the same way:\n\nplot(tree; branchpoints=true, idxs=[2])\n\nIt is possible to plot multiple variables in the same plot, but since branching can result in many particles and line color is already used to distinguish different particles in the tree, this is not particularly illuminating:\n\nplot(tree; branchpoints=true, idxs=[1,2])","category":"section"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#BranchingProcesses.tip_values","page":"Utilities","title":"BranchingProcesses.tip_values","text":"tip_values(tree::BranchingProcessSolution)\n\nReturn the values at the tips of a [BranchingProcessSolution](@docs) tree.\n\nSee also: nodevalue\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.reduce_tree","page":"Utilities","title":"BranchingProcesses.reduce_tree","text":"reduce_tree(tree::BranchingProcessSolution)\n\nReduce BranchingProcessSolution tree to an ordinary time series by combining the values of all particles alive at each time point. The timespan of the resulting time series is from the initial time of the root to the latest final time of any of the leaves of the input tree; the time points are spaced by dt (default: 0.01). The function transform (default: identity) is applied to the values of each particle before combining them. The function reduction (either \"sum\" (default) or \"prod\") is used to combine the (transformed) values of all particles alive at each time point.\n\nNote that if the resulting time series has different time points than the original trajectories in the input tree, the interpolating function of the solver used to sample the original trajectories is used to compute the reduced time series. Any keyword arguments kwargs... (for instance idxs=[1,3,5] to summarize only a subset variables) are passed to the interpolating function. \n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.node_generations","page":"Utilities","title":"BranchingProcesses.node_generations","text":"node_generations(root::BranchingProcessNode)\n\nCompute the generation (distance from root) for all nodes in the tree. Returns a dictionary mapping each node to its generation, where the root has generation 0, its direct children have generation 1, etc.\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_transform","page":"Utilities","title":"BranchingProcesses.get_transform","text":"get_transform(sol::ReducedBranchingProcessSolution)\n\nGet the transformation function used in the reduction.\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_reduction_method","page":"Utilities","title":"BranchingProcesses.get_reduction_method","text":"get_reduction_method(sol::ReducedBranchingProcessSolution)\n\nGet the reduction method used to combine particle values.\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_original_solution","page":"Utilities","title":"BranchingProcesses.get_original_solution","text":"get_original_solution(sol::ReducedBranchingProcessSolution)\n\nGet the original BranchingProcessSolution that was reduced (if available).\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.has_original_solution","page":"Utilities","title":"BranchingProcesses.has_original_solution","text":"has_original_solution(sol::ReducedBranchingProcessSolution)\n\nCheck if the original BranchingProcessSolution is stored.\n\n\n\n\n\n","category":"function"},{"location":"examples/ensemble-simulation/#Ensemble-simulations","page":"Ensemble simulations","title":"Ensemble simulations","text":"In a Luria-Delbrück experiment, here called a fluctuation experiment, multiple clones are grown, each starting from a different single cell.\n\nTo simulate fluctuation experiments, the BranchingProcesses package supports SciML's parallel ensemble simulation methods.[1]\n\n[1]: It would be more accurate to say that SciML is providing the support: because the BranchingProcesses package implements SciMLBase.solve, parallel ensemble simulations are supported out of the box.\n\nLet's model the actual Luria-Delbrück experiment as a birth-death process where a cell can switch from  wild-type to mutant, without any back-mutations:\n\nusing DifferentialEquations, JumpProcesses, Catalyst\nrn = @reaction_network begin\n    μ, W --> M\nend\nu0 = [:W => 1, :M => 0]  # Always start in the wild-type state\np = [:μ => 0.01]  # Mutation rate\ntspan = (0.0, 10.0)\ndprob = DiscreteProblem(rn, u0, tspan, p)\njprob = JumpProblem(rn, dprob, Direct())\n\nDefine a branching process problem:\n\nusing BranchingProcesses\nλ = 1.0\nnchild = 2\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nnothing # hide\n\nTo simulate a fluctuation experiment with 100 clones, first set up an EnsembleProblem:\n\nensemble_bjprob = EnsembleProblem(bjprob)\n\nThen solve the problem:\n\nensemble_sol = solve(ensemble_bjprob, SSAStepper(), EnsembleThreads(), trajectories=100)\n\nWe can obtain the number of cells and the number of mutants in each clone using the tip_values function:\n\ncell_counts = [sum(tip_values(sol)) for sol in ensemble_sol];\ntotal_cell_counts = [sum(x) for x in cell_counts];\nmutant_cell_counts = [x[2] for x in cell_counts];\nnothing # hide\n\nusing Plots\nhistogram(total_cell_counts,label=\"\",xlabel=\"Total cell counts\", ylabel=\"Number of clones\")\n\nhistogram(mutant_cell_counts,label=\"\",xlabel=\"Mutant cell counts\", ylabel=\"Number of clones\")","category":"section"},{"location":"examples/branching-brownian-motion/#Branching-Brownian-motion","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Branching Brownian motion (BBM) is the simplest example of a branching stochastic process. The process starts with a \"root\" particle undergoing Brownian motion. After an exponentially distributed lifetime, the particle dies and gives rise to a number of offspring particles, each evolving independently by the same mechanisms, with initial position given by the final position of the parent particle.","category":"section"},{"location":"examples/branching-brownian-motion/#Setting-up-the-problem","page":"Branching Brownian motion","title":"Setting up the problem","text":"In SciML, a \"problem\" is the encoding of a mathematical problem into a numerically computable form. A branching stochastic process problem is defined mathematically by three ingredients:\n\na stochastic process defining the single-particle dynamics,\na branching rate,\na branching mechanism.\n\nFor BBM, the single-particle dynamics is Brownian motion, or more precisely, the Wiener process. It is defined in a distributionally exact manner in the DiffEqNoiseProcess package, but for now the BranchingProcesses package only supports SDEProblem or JumpProblem types. Hence we define the Wiener process as the SDEProblem:\n\nusing DifferentialEquations\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)\n\nThe branching rate is a constant,\n\nλ = 1.0\n\nand the branching mechanism, for now, is taken as deterministic splitting into two particles,\n\nnchild = 2\n\nThe three ingredients defining BBM can now be packed in a ConstantRateBranchingProblem:\n\nusing BranchingProcesses\nbbm = ConstantRateBranchingProblem(bm, λ, nchild)\n\nBranchingProcesses does not yet support branching with non-constant, that is, time and/or state-dependent branching rates.\n\nnote: Timespan of the branching process\nBy convention it is assumed that the timespan argument tspan used to define the single-particle dynamics problem is the requested timespan of the entire branching process. In other words, the branching process bbm will be simulated for the timespan:bbm.prob.tspan","category":"section"},{"location":"examples/branching-brownian-motion/#Sampling-a-trajectory","page":"Branching Brownian motion","title":"Sampling a trajectory","text":"In SciML, sampling a trajectory of a stochastic process is done by solving the problem. BranchingProcesses follows this convention, and hence we can run:\n\nusing Random # hide\nRandom.seed!(123) # hide\nsol = solve(bbm, EM(); dt=0.01);\n\nThe (optional) second argument in the solve function specifies the algorithm used to simulate the single-particle dynamics, see the SDE solvers page for a full list of available algorithms. Any optional keyword arguments are also directly passed to the chosen single-particle simulation algorithm.\n\nThe output of solve is a BranchingProcessSolution, a tree structure where each node contains the solution (simulated trajector) of a particle in the branching process trajectory, as well as pointers to the solutions of its children.\n\nA plot recipe is included in the BranchingProcesses package to plot the sampled trajectory using the standard plot command, which accepts the usual attributes for a series of type \"path\":\n\nusing Plots\nplot(sol; linewidth=2)\n\nOptionally, the branchpoints (birth times and values of each particle) can be included in the plot:\n\nplot(sol; linewidth=2, branchpoints=true)\n\nThe size, shape, color, etc. of the branchpoint markers can be changed using the usual attributes\n\nThe plot recipe for a BranchingProcessSolution calls another recipe for a BranchingProcessNode on the solution's root node sol.tree. Hence we can plot any subtree of the solution by plotting a specific node, for instance:\n\nplot(sol.tree.children[1].children[1]; linewidth=2, branchpoints=true)","category":"section"},{"location":"examples/branching-brownian-motion/#Non-deterministic-offspring-distribution","page":"Branching Brownian motion","title":"Non-deterministic offspring distribution","text":"In the setup above, each particle gives rise to two offspring particles at the end of its lifetime, resulting in an exponential increase in the number of particles over time. Non-deterministic offspring distributions are also supported. For instance, in a cell division model, we can assume that cells divide (2 offspring), enter or remain is a quiescent, non-dividing state (1 offspring, itself), or die (0 offpsring), each with some probability. In such a scenario, we define the number of children nchild as a univariate discrete distribution:\n\nusing Distributions\nnchild2 = DiscreteNonParametric([0, 1, 2], [0.2, 0.5, 0.3])\n\nThe branching process problem is constructed, solved, and plotted as before:\n\nRandom.seed!(15) # hide\nbbm2 = ConstantRateBranchingProblem(bm, λ, nchild2)\nsol2 = solve(bbm2, EM(); dt=0.01);\nplot(sol2; linewidth=2, branchpoints=true)","category":"section"},{"location":"examples/abstracttrees-interface/#AbstractTrees-interface","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"A BranchingProcessSolution is an AbstractTrees instance in which each node is represented by an AbstractSciMLSolution. Hence useful statistics of the sampled branching process trajectory can be obtained by combining features of these two types.","category":"section"},{"location":"examples/abstracttrees-interface/#Tree-statistics","page":"AbstractTrees interface","title":"Tree statistics","text":"Useful tree statistics can be obtained directly from the AbstractTrees interface. To illustrate this, consider the example of branching Brownian motion:\n\nusing DifferentialEquations, BranchingProcesses\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)\nλ = 1.0\nnchild = 2\nbbm = ConstantRateBranchingProblem(bm, λ, nchild)\nusing Random # hide\nRandom.seed!(123) # hide\nsol = solve(bbm, EM(); dt=0.01)\n\nThe number of particles alive at the end of the sampled trajectory is:\n\nusing AbstractTrees\nnum_alive = treebreadth(sol)\n\nThe longest lineage in the tree is:\n\nmax_lineage_length = treeheight(sol)\n\nNote that the actual tree structure implementing the AbstractTrees interface is the field sol.tree of type BranchingProcessNode. When tree operations like the ones above are called on a BranchingProcessSolution, they are delegated to the tree field. Hence we can call the same operations on any instance of aBranchingProcessNode, for instance\n\nnum_alive_sub = treebreadth(sol.tree.children[1])","category":"section"},{"location":"examples/abstracttrees-interface/#Values-at-the-tips-of-a-branching-process","page":"AbstractTrees interface","title":"Values at the tips of a branching process","text":"We are often interested in the values at the tips of a branching process, that is, the values at the final time T of a branching experiment of the particles alive at that time. To obtain these values, we use an iterator over the leaves of the tree and use the array interface for SciMLSolutions:\n\ntip_vals = [node.sol[end] for node in Leaves(sol)] \n\nAgain the call Leaves(sol) is delegated to its tree field, that is, it is equivalent to Leaves(sol.tree).\n\nBecause it is common to need the final value of a particle, this has been implemented as the value associated with a node:\n\ntip_vals == [nodevalue(node) for node in Leaves(sol)] \n\nAn even shorter short-cut is to call the function tip_values:\n\ntip_vals = tip_values(sol)\nnothing # hide","category":"section"},{"location":"#BranchingProcesses.jl","page":"Introduction","title":"BranchingProcesses.jl","text":"","category":"section"},{"location":"#BranchingProcesses.BranchingProcesses","page":"Introduction","title":"BranchingProcesses.BranchingProcesses","text":"Exports\n\nBranchingProcessNode\nBranchingProcessSolution\nConstantRateBranchingProblem\nReducedBranchingProcessSolution\nget_timespan\nnode_generations\nreduce_tree\nremake_initial_condition\nsample_lifetime\nsample_offspring\nsolve\nsolve_and_split\ntip_values\n\nImports\n\nAbstractTrees\nBase\nColorSchemes\nDistributions\nDocStringExtensions\nRecipesBase\nSciMLBase\n\nBranchingProcesses\n\n(Image: Dev) (Image: Build Status)\n\nBranchingProcesses is a Julia package for modelling branching stochastic processes, also known as branching particle systems. \n\nBranching stochastic processes are processes where \"particles\" (which could represent cells, individuals, or species depending on the context) have one or more degrees of freedom X(t) whose dynamics is described by a stationary Markov process. After a certain lifetime, a particle splits into kgeq 0 identical, independent offspring particles with probability p_k. This process is repeated indefinitely, producing a collection of N(t) particles at time t. Splitting happens with a rate function gamma(t) that may depend on the age t of the particle.\n\nExamples of such processes are:\n\nClassical branching processes, which correspond to the case X(t)equiv 1.\nBranching Brownian motion\nBranching Ornstein-Uhlenbeck processes used in phylogenetic comparative methods\n\nAlthough the package can probably be used or extended for generic phylodynamic analyses, the dedicated PhyloTraits package will probably be more appropriate for that purpose.\n\nThe primary motivation for this package is to provide a framework for the analysis of a \"memory\" phenomenon that can occur in branching stochastic processes if the relaxation rate of the single-particle dynamics is slow relative to the branching rate. In this case the system can remember its initial state, or, put differently, large fluctuations early in the expansion can have a long-lasting effect on the state of the system. The study of this phenomenon implicitly traces its roots (no pun intended) to Luria and Delbrück's fluctuation analysis. More recently, it has been\n\nstudied mathematically in branching Ornstein-Uhlenbeck processes,\nobserved experimentally in proliferating cancer cell populations\nproposed as an important property of proliferating active matter\n\nStudying this phenomenon requires the analysis of fluctuations across multiple independent realizations of the branching process. This is in contrast to the more common use of branching processes in population and phylogenetics, where the focus is on the evolution of a single lineage.\n\nSupported stochastic processes\n\nThe aim is to support any process that can be implemented as a stochastic differential equation, jump process, or jump diffusion equation. \n\nSpecific branching process constructors will be implemented for the following stochastic processes:\n\nBrownian motion\nOrnstein-Uhlenbeck process\nBirth-death process\nThe stochastic gene expression models of Gorin et al (2022)\n\nFor now, see the examples in the documentation for how to construct branching processes.\n\nSupported lifetime distributions\n\nA branching rate function gamma(t) defines a lifetime distribution w(t)=exp(-int_0^t dsgamma(s)), and vice versa, where w(t) is the probability of a particle to reach age t without splitting. The package uses the lifetime distribution representation and supports any univariate distribution with positive support.\n\nSupported splitting distributions\n\nAny discrete univariate distribution (default: Dirac with parameter 2, that is, all particles split into two offspring particles).\n\n\n\n\n\n","category":"module"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Problem-types","page":"Types","title":"Problem types","text":"","category":"section"},{"location":"types/#Solution-types","page":"Types","title":"Solution types","text":"","category":"section"},{"location":"types/#BranchingProcesses.ConstantRateBranchingProblem","page":"Types","title":"BranchingProcesses.ConstantRateBranchingProblem","text":"struct ConstantRateBranchingProblem{P<:SciMLBase.AbstractDEProblem, L<:(UnivariateDistribution), O<:Union{Integer, DiscreteUnivariateDistribution, UnivariateDistribution{Discrete}, DiscreteDistribution{Univariate}}} <: BranchingProcesses.BranchingProblem\n\nA structure to define a branching stochastic process with constant branching rate.\n\nFields\n\nprob: The SDE or jump process problem defining the single-particle dynamics of the branching process, an instance of SciMLBase.AbstractSDEProblem or SciMLBase.AbstractJumpProblem.\nlifetime: The lifetime distribution of the process, which must be a discrete or continuous univariate distribution with positive support.\nnchild: The number of children to be created for each particle, which can be a non-negative integer or a discrete distribution with non-negative support from which the number of children is sampled.\n\n\n\n\n\n","category":"type"},{"location":"types/#BranchingProcesses.BranchingProcessSolution","page":"Types","title":"BranchingProcesses.BranchingProcessSolution","text":"struct BranchingProcessSolution{P<:BranchingProcesses.BranchingProblem, T<:Union{DESolution, SciMLSolution}}\n\nA complete solution of a branching stochastic process, containing both the problem definition and the resulting tree structure.\n\nFields\n\nprob: The branching problem that was solved.\ntree: The root node of the solution tree.\nalg: Algorithm used to solve the problem (optional).\nretcode: Return code indicating success/failure.\nstats: Additional statistics or metadata (optional).\n\n\n\n\n\n","category":"type"},{"location":"types/#BranchingProcesses.BranchingProcessNode","page":"Types","title":"BranchingProcesses.BranchingProcessNode","text":"struct BranchingProcessNode{T<:Union{DESolution, SciMLSolution}}\n\nA tree node structure to hold individual particle solutions in a branching process.\n\nFields\n\nsol: The solution of the particle associated to this node.\nchildren: A vector of child nodes representing offspring particles.\n\n\n\n\n\n","category":"type"},{"location":"types/#AbstractTrees.children","page":"Types","title":"AbstractTrees.children","text":"AbstractTrees.children(node::BranchingProcessNode)\n\nReturn the children of a BranchingProcessNode.\n\n\n\n\n\n","category":"function"},{"location":"types/#AbstractTrees.nodevalue","page":"Types","title":"AbstractTrees.nodevalue","text":"AbstractTrees.nodevalue(node::BranchingProcessNode)\n\nReturn the value of a BranchingProcessNode, defined as its final state value.\n\n\n\n\n\n","category":"function"},{"location":"types/#BranchingProcesses.ReducedBranchingProcessSolution","page":"Types","title":"BranchingProcesses.ReducedBranchingProcessSolution","text":"struct ReducedBranchingProcessSolution{T, N, uType, tType, P, A, IType, TransType, RedType, OrigType} <: SciMLBase.AbstractTimeseriesSolution{T, N, uType}\n\nA solution type for the output of reduce_tree. Contains the reduced time series from a branching process tree where values of all particles alive at each time point have been combined using a reduction function.\n\nFields\n\nu: The reduced values at each time point.\nt: The time points.\nprob: The original branching problem (optional).\nalg: Algorithm information (optional).\ndense: Whether dense output is available.\ninterp: Interpolation object.\ntslocation: Time series location.\nretcode: Return code.\ntransform: Transformation function applied to particle values before reduction.\nreduction: Reduction method used to combine particle values (\"sum\", \"prod\", or custom function).\noriginal_solution: Original BranchingProcessSolution that was reduced (optional).\n\n\n\n\n\n","category":"type"}]
}
