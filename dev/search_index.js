var documenterSearchIndex = {"docs":
[{"location":"examples/branching-brownian-motion/#Branching-Brownian-motion","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Branching Brownian motion (BBM) is the simplest example of a branching stochastic process. The process starts with a \"root\" particle undergoing Brownian motion. After an exponentially distributed lifetime, the particle dies and gives rise to a number of offspring particles, each evolving independently by the same mechanisms, with initial position given by the final position of the parent particle.","category":"page"},{"location":"examples/branching-brownian-motion/#Setting-up-the-problem","page":"Branching Brownian motion","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In SciML, a \"problem\" is the encoding of a mathematical problem into a numerically computable form. A branching stochastic process problem is defined mathematically by three ingredients:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"a stochastic process defining the single-particle dynamics,\na branching rate,\na branching mechanism.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"For BBM, the single-particle dynamics is Brownian motion, or more precisely, the Wiener process. It is defined in a distributionally exact manner in the DiffEqNoiseProcess package, but for now the BranchingProcesses package only supports SDEProblem or JumpProblem types. Hence we define the Wiener process as the SDEProblem:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using DifferentialEquations\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The branching rate is a constant,","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"λ = 1.0","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"and the branching mechanism, for now, is taken as deterministic splitting into two particles,","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"nchild = 2","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The three ingredients defining BBM can now be packed in a ConstantRateBranchingProblem:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"import BranchingProcesses as BP\nbbm = BP.ConstantRateBranchingProblem(bm, λ, nchild)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"BranchingProcesses does not yet support branching with non-constant, that is, time and/or state-dependent branching rates.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"note: Timespan of the branching process\nBy convention it is assumed that the timespan argument tspan used to define the single-particle dynamics problem is the requested timespan of the entire branching process. In other words, the branching process bbm will be simulated for the timespan:bbm.prob.tspan","category":"page"},{"location":"examples/branching-brownian-motion/#Sampling-a-trajectory","page":"Branching Brownian motion","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In SciML, sampling a trajectory of a stochastic process is done by solving the problem. BranchingProcesses follows this convention, and hence we can run:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Random # hide\nRandom.seed!(123) # hide\ntree = solve(bbm, EM(); dt=0.01)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The (optional) second argument in the solve function specifies the algorithm used to simulate the single-particle dynamics, see the SDE solvers page for a full list of available algorithms. Any optional keyword arguments are also directly passed to the chosen single-particle simulation algorithm.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The output of solve is a BranchingProcessSolution, a tree structure where each node contains the solution (simulated trajector) of a particle in the branching process trajectory, as well as pointers to the solutions of its children.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"A plot recipe is included in the BranchingProcesses package to plot the sampled trajectory using the standard plot command, which accepts the usual attributes for a series of type \"path\":","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Plots\nplot(tree; linewidth=2)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Optionally, the branchpoints (birth times and values of each particle) can be included in the plot:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Plots\nplot(tree; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The size, shape, color, etc. of the branchpoint markers can be changed using the usual attributes","category":"page"},{"location":"examples/branching-brownian-motion/#Non-deterministic-offspring-distribution","page":"Branching Brownian motion","title":"Non-deterministic offspring distribution","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In the setup above, each particle gives rise to two offspring particles at the end of its lifetime, resulting in an exponential increase in the number of particles over time. Non-deterministic offspring distributions are also supported. For instance, in a cell division model, we can assume that cells divide (2 offspring), enter or remain is a quiescent, non-dividing state (1 offspring, itself), or die (0 offpsring), each with some probability. In such a scenario, we define the number of children nchild as a univariate discrete distribution:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Distributions\nnchild2 = DiscreteNonParametric([0, 1, 2], [0.2, 0.5, 0.3])","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The branching process problem is constructed, solved, and plotted as before:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Random.seed!(15) # hide\nbbm2 = BP.ConstantRateBranchingProblem(bm, λ, nchild2)\ntree2 = solve(bbm2, EM(); dt=0.01)\nplot(tree2; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"examples/branching-oup/#Branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"The Ornstein-Uhlenbeck process (OUP) is defined by the stochastic differential equation","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"dX_t = alpha (mu -  X_t)dt + sigma dW_t","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"and describes a variable X_t which fluctuates stochastically around its average or steady-state value mu; alpha0 is the rate at which fluctuations return to their steady-state value, sigma0 defines the relative magnitude of the stochastic fluctuations, and W_t is the Wiener process.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"If X_t represents the expression level of a gene, then the OUP is the simplest model of stochastic gene expression. The branching OUP can then be used to model the evolution of gene expression during cell proliferation.[1] At the opposite end of biological time scales, the branching OUP is also used as a model for the evolution of traits under selection in a phylogenetic tree.[2]","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"[1]: To be precise, during proliferation, cells first double in size and then divide in two daughter cells half the size. If we don't explicitly model this doubling-halving cycle, X_t represents a concentration rather than a absolute level.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"[2]: See Hansen (1997) or these and other lectures by Paul Bastide.","category":"page"},{"location":"examples/branching-oup/#Setting-up-the-problem","page":"Branching Ornstein-Uhlenbeck process","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"Similar to the branching Brownian motion tutorial, we cannot (yet) use the distributionally exact OUP implementation from the DiffEqNoiseProcess package, but must define the OUP as a SDEProblem:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using DifferentialEquations\nf(u,p,t) = p[2]*(p[1]-u)\ng(u,p,t) = p[3]\nu0 = 0.0\ntspan = (0.0, 5.0)\nμ = 2.0\nα = 5.0\nσ = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We can first verify that after an initial \"burn-in\" period, the OUP indeed fluctuates around its steady-state value mu:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using Plots\nsol = solve(oup, EM(), dt=0.01)\nplot(sol; linewidth=2, legend=false)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We can now set up the branching OUP problem in the same way as in the branching Brownian motion tutorial:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"import BranchingProcesses as BP\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nboup = BP.ConstantRateBranchingProblem(oup, λ, nchild)","category":"page"},{"location":"examples/branching-oup/#Sampling-a-trajectory","page":"Branching Ornstein-Uhlenbeck process","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using Random\nRandom.seed!(123)\ntree = solve(boup, EM(); dt=0.01)\nplot(tree; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We observe that after a few generations, all cells fluctuate around their steady state value mu=20.","category":"page"},{"location":"examples/branching-oup/#Memory-in-the-branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Memory in the branching Ornstein-Uhlenbeck process","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"The dynamics of the branching OUP is driven by two parallel processes, the return to steady-state with rate alpha and the branching with rate lambda. If the half-life ln 2alpha of the stochastic fluctuations is short compared to the average lifetime 1lambda of a cell, each cell has sufficient time to equilibrate and the population as a whole will be distributed around the steady-state value, as in the figure above.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"However, if the half-life of the stochastic fluctuations is long compared to the average lifetime of a cell, large fluctuations early in the expansion can have a long-lasting effect on the population as a whole. This is the memory phenomenon referred to in the BranchingProcesses package introduction. For the branching OUP specifically, this phenomenon has been analyzed in great mathematical detail.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"To illustrate this phenomenon, we set the same random seed as above (to ensure exactly the same branching times) and only change the value of alpha:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"α = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = BP.ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\ntree = solve(boup, EM(); dt=0.01)\nplot(tree; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We observe that the system now did not have sufficient time to equilibrate within the typical life-time of a cell, and the population as a whole is shifted towards, that is, remembers, its initial state.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"That the memory is due to the slow return to steady-state of the fluctuations and not the value of the initial state can be seen by starting the same problem in the steady state itself:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"α = 0.5\nu0 = μ\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = BP.ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\ntree = solve(boup, EM(); dt=0.01)\nplot(tree; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"Again we observe a shifted distribution due to large fluctuations early in the expansion.","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(bp::T, alg::A; kwargs...) where {T<:ConstantRateBranchingProblem, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nSolve a branching stochastic process with constant branching rate defined by the ConstantRateBranchingProblem bp. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample trajectories of the underlying SDE problem.\n\nSee also: ConstantRateBranchingProblem, solve_and_split_constantrate, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.solve_and_split_constantrate","page":"Solvers","title":"BranchingProcesses.solve_and_split_constantrate","text":"solve_and_split_constantrate(prob::T, λ::S, nchild::O, alg::A; kwargs...) where {T<:SciMLBase.AbstractDEProblem, S<:Real, O<:Union{Integer,DiscreteUnivariateDistribution}, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nRecursively solve a branching stochastic process where the single-particle dynamics is defined by the SDE problem prob, the branching rate is a constant λ, and the number of children nchild of each particle is either a non-negative integer or a discrete distribution from which the number of children is sampled. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample the trajectory of each particle.\n\nThe timespan of the problem prob defines the total time interval for the branching process. A lifetime for the first particle is sampled from an exponential distribution with rate λ. If the lifetime is larger than the total time interval, the problem is solved until the end of the original interval and a solution node is returned without children. If the lifetime is smaller than the total time interval, the problem is solved until the sampled lifetime, and a solution node is returned with recursively solved children for the remaining time interval.\n\nSee also: SDE problems, sample_lifetime_constantrate, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_lifetime_constantrate","page":"Solvers","title":"BranchingProcesses.sample_lifetime_constantrate","text":"sample_lifetime_constantrate(λ::T) where T <: Real\n\nSample the lifetime of a particle when the branching rate is a constant λ independent of time or the value of the process. This is equivalent to sampling from an exponential distribution with rate λ.\n\nNote that this is not the same as a ConstantRateJump where the rate is only constant between jumps.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_offspring","page":"Solvers","title":"BranchingProcesses.sample_offspring","text":"sample_offspring(nchild::O) where O<:Union{Integer,DiscreteUnivariateDistribution}\n\nSample the number of offspring for a particle. If the input nchild is an integer, that integer is returned. If nchild is a discrete distribution, a sample from that distribution is returned.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.remake_initial_condition","page":"Solvers","title":"BranchingProcesses.remake_initial_condition","text":"remake_initial_condition(prob::P, tspan, u0=nothing) where P<:SciMLBase.AbstractDEProblem\n\nRemake the problem prob with a new timespan tspan and, optionally, a new initial condition u0. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.get_timespan","page":"Solvers","title":"BranchingProcesses.get_timespan","text":"get_timespan(prob::P) where P<:SciMLBase.AbstractDEProblem\n\nGet the timespan of the problem prob. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\n","category":"function"},{"location":"examples/multi-variable-processes/#Multi-variable-branching-stochastic-processes","page":"Multi-variable branching processes","title":"Multi-variable branching stochastic processes","text":"","category":"section"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"The single-particle or single-cell stochastic process undergoing branching can be a multi-variable process. To illustrate this, consider the example of Michaelis-Menten enzyme kinetics, where an enzyme (E) transforms a substrate (S) into a product (P). The reaction network is defined in the Catalyst library of basic chemical reaction network models:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Catalyst\nmm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"We set up a single-cell process (with four variables, S. E. SE. and P) as in the model library:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using DifferentialEquations, JumpProcesses\nu0 = [:S => 30, :E => 10, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\n\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"A trajectory for a single cell can be sampled and plotted:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"A branching jump problem is set up as usual:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"import BranchingProcesses as BP\nλ = 0.05         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = BP.ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"To sample a tranjectory of the branching process, we call the solve function as usual:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Random # hide\nRandom.seed!(123) # hide\nusing AbstractTrees\ntree = BP.solve(bjprob,  SSAStepper());\ntreeheight(tree)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"If we plot the solution, by default the trajectory for the first variable is shown:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; add_branchpoints=true)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"Because the plot recipe piggybacks on the plot recipe for differential equation solutions, variables for plotting can be chose in the same way:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; add_branchpoints=true, idxs=[2])","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"It is possible to plot multiple variables in the same plot, but since branching can result in many particles and line color is already used to distinguish different particles in the tree, this is not particularly illuminating:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; add_branchpoints=true, idxs=[1,2])","category":"page"},{"location":"examples/abstracttrees-interface/#AbstractTrees-interface","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"A BranchingProcessSolution is an AbstractTrees instance in which each node is represented by an AbstractSciMLSolution. Hence useful statistics of the sampled branching process trajectory can be obtained by combining features of these two types.","category":"page"},{"location":"examples/abstracttrees-interface/#Tree-statistics","page":"AbstractTrees interface","title":"Tree statistics","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Useful tree statistics can be obtained directly from the AbstractTrees interface. To illustrate this, consider the example of branching Brownian motion:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"import BranchingProcesses as BP\nusing DifferentialEquations\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)\nλ = 1.0\nnchild = 2\nbbm = BP.ConstantRateBranchingProblem(bm, λ, nchild)\nusing Random # hide\nRandom.seed!(123) # hide\ntree = solve(bbm, EM(); dt=0.01)","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"The number of particles alive at the end of the sampled trajectory is:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"using AbstractTrees\nnum_alive = treebreadth(tree)","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"The longest lineage in the tree is:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"max_lineage_length = treeheight(tree)","category":"page"},{"location":"examples/abstracttrees-interface/#Values-at-the-tips-of-a-branching-process","page":"AbstractTrees interface","title":"Values at the tips of a branching process","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"We are often interested in the values at the tips of a branching process, that is, the values at the final time T of a branching experiment of the particles alive at that time. To obtain these values, we use an iterator over the leaves of the tree and use the array interface for SciMLSolutions:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"tip_values = [node.sol[end] for node in Leaves(tree)] ","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Because it is common to need the final value of a particle, this has been implemented as the value associated with a node:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"tip_values == [nodevalue(node) for node in Leaves(tree)] ","category":"page"},{"location":"examples/branching-birth-death/#Branching-birth-death-processes","page":"Branching birth-death process","title":"Branching birth-death processes","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"In the branching Ornstein-Uhlenbeck process example, we considered the Ornstein-Uhlenbeck process (OUP) as a simple model for stochastically fluctuating gene expression. However, gene expression is modelled more realistically as a process taking discrete values representing molecule counts.","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"If we assume molecules are produced and degraded one at a time, we obtain a birth-death process. Such processes, and many other more complicated processes, are most easily defined using the Catalyst reaction network modelling language.","category":"page"},{"location":"examples/branching-birth-death/#Setting-up-the-problem","page":"Branching birth-death process","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"We first define the single-particle, in our case single-cell, dynamics as a reaction network:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Catalyst\nrn = @reaction_network begin\n    kp, 0 --> X\n    kd, X --> 0\nend","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"where kp and kd are the parameters of the model, respectively the production and degradation rates.","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"As explained in the Catalyst tutorials, we can define a JumpProcess to simulate this reaction network as follows:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using DifferentialEquations, JumpProcesses\nu0 = [200]\ntspan = (0.0, 3.0)\np = [:kp => 50.0, :kd => 0.25]\njinput = JumpInputs(rn, u0, tspan, p)\njprob = JumpProblem(jinput)","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"A trajectory for a single cell can be sampled and plotted:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"A branching jump problem is set up as in the branching Brownian motion and branching Ornstein-Uhlenbeck process examples:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"import BranchingProcesses as BP\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = BP.ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/branching-birth-death/#Sampling-a-trajectory","page":"Branching birth-death process","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Random # hide\nRandom.seed!(123) # hide\ntree = BP.solve(bjprob,  SSAStepper());\nplot(tree; linewidth=2, add_branchpoints=true)","category":"page"},{"location":"#BranchingProcesses.jl","page":"Introduction","title":"BranchingProcesses.jl","text":"","category":"section"},{"location":"#BranchingProcesses.BranchingProcesses","page":"Introduction","title":"BranchingProcesses.BranchingProcesses","text":"Exports\n\nImports\n\nAbstractTrees\nBase\nCore\nDistributions\nDocStringExtensions\nRecipesBase\nSciMLBase\n\nBranchingProcesses\n\n(Image: Dev) (Image: Build Status)\n\nBranchingProcesses is a Julia package for modelling branching stochastic processes, also known as branching particle systems. \n\nBranching stochastic processes are processes where \"particles\" (which could represent cells, individuals, or species depending on the context) have one or more degrees of freedom X(t) whose dynamics is described by a stationary Markov process. After a certain lifetime, a particle splits into kgeq 0 identical, independent offspring particles with probability p_k. This process is repeated indefinitely, producing a collection of N(t) particles at time t. Splitting happens with a rate function gamma(xtau) that may depend on the current state x and age tau of the particle.\n\nExamples of such processes are:\n\nClassical branching processes, which correspond to the case X(t)equiv 1.\nBranching Brownian motion\nBranching Ornstein-Uhlenbeck processes used in phylogenetic comparative methods\n\nAlthough the package can probably be used or extended for generic phylodynamic analyses, the dedicated PhyloTraits package will probably be more appropriate for that purpose.\n\nThe primary motivation for this package is to provide a framework for the analysis of a \"memory\" phenomenon that can occur in branching stochastic processes if the relaxation rate of the single-particle dynamics is slow relative to the branching rate. In this case the system can remember its initial state, or, put differently, large fluctuations early in the expansion can have a long-lasting effect on the state of the system. The study of this phenomenon implicitly traces its roots (no pun intended) to Luria and Delbrück's fluctuation analysis. More recently, it has been\n\nstudied mathematically in branching Ornstein-Uhlenbeck processes,\nobserved experimentally in proliferating cancer cell populations\nproposed as an important property of proliferating active matter\n\nStudying this phenomenon requires the analysis of fluctuations across multiple independent realizations of the branching process. This is in contrast to the more common use of branching processes in population and phylogenetics, where the focus is on the evolution of a single lineage.\n\nSupported stochastic processes\n\nThe aim is to support any process that can be implemented as a stochastic differential equation, jump process, or jump diffusion equation. \n\nSpecific processes that will be implemented in the package are:\n\nBrownian motion\nOrnstein-Uhlenbeck process\nBirth-death process\nThe stochastic gene expression models of Gorin et al (2022)\n\nSupported rate function\n\nAny valid constant or variable rate function. The default is a constant rate function with parameter 1, that is, the probability for a particle to be alive with lifetime tau is exp(-tau).\n\nSupported splitting distributions\n\nAny discrete univariate distribution (default: Dirac with parameter 2, that is, all particles split into two offspring particles).\n\n\n\n\n\n","category":"module"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Problem-types","page":"Types","title":"Problem types","text":"","category":"section"},{"location":"types/#BranchingProcesses.ConstantRateBranchingProblem","page":"Types","title":"BranchingProcesses.ConstantRateBranchingProblem","text":"struct ConstantRateBranchingProblem{P<:SciMLBase.AbstractDEProblem, R<:Real, O<:Union{Integer, Distributions.DiscreteUnivariateDistribution, Distributions.UnivariateDistribution{Distributions.Discrete}, Distributions.DiscreteDistribution{Distributions.Univariate}}} <: BranchingProcesses.BranchingProblem\n\nA structure to define a branching stochastic process with constant branching rate.\n\nFields\n\nprob: The SDE or jump process problem defining the single-particle dynamics of the branching process, an instance of SciMLBase.AbstractSDEProblem or SciMLBase.AbstractJumpProblem.\nbranchrate: The branching rate of the process, which must be a positive real number.\nnchild: The number of children to be created for each particle, which can be a non-negative integer or a discrete distribution with non-negative support from which the number of children is sampled.\n\n\n\n\n\n","category":"type"},{"location":"types/#Solution-types","page":"Types","title":"Solution types","text":"","category":"section"},{"location":"types/#BranchingProcesses.BranchingProcessSolution","page":"Types","title":"BranchingProcesses.BranchingProcessSolution","text":"struct BranchingProcessSolution{T<:Union{SciMLBase.DESolution, SciMLBase.SciMLSolution}}\n\nA tree structure to hold a solution of a branching stochastic process.\n\nFields\n\nsol: The solution, that is, sample trajectory, of the particle associated to the node, which is an instance of SciMLBase.AbstractSciMLSolution.\nchildren: a vector of BranchingProcessSolution instances representing the child particles of the current particle.\n\nThe solution type T must be the same for all nodes in the tree.\n\n\n\n\n\n","category":"type"},{"location":"types/#AbstractTrees.children","page":"Types","title":"AbstractTrees.children","text":"AbstractTrees.children(node::BranchingProcessSolution)\n\nReturn the children of a BranchingProcessSolution node.\n\n\n\n\n\n","category":"function"},{"location":"types/#AbstractTrees.nodevalue","page":"Types","title":"AbstractTrees.nodevalue","text":"AbstractTrees.nodevalue(node::BranchingProcessSolution)\n\nReturn the value of a BranchingProcessSolution node, defined as its final state value.\n\n\n\n\n\n","category":"function"}]
}
