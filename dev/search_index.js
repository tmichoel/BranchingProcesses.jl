var documenterSearchIndex = {"docs":
[{"location":"examples/branching-oup/#Branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"The Ornstein-Uhlenbeck process (OUP) is defined by the stochastic differential equation","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"dX_t = alpha (mu -  X_t)dt + sigma dW_t","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"and describes a variable X_t which fluctuates stochastically around its average or steady-state value mu; alpha0 is the rate at which fluctuations return to their steady-state value, sigma0 defines the relative magnitude of the stochastic fluctuations, and W_t is the Wiener process.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"If X_t represents the expression level of a gene, then the OUP is the simplest model of stochastic gene expression. The branching OUP can then be used to model the evolution of gene expression during cell proliferation.[1] At the opposite end of biological time scales, the branching OUP is also used as a model for the evolution of traits under selection in a phylogenetic tree.[2]","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"[1]: To be precise, during proliferation, cells first double in size and then divide in two daughter cells half the size. If we don't explicitly model this doubling-halving cycle, X_t represents a concentration rather than a absolute level.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"[2]: See Hansen (1997) or these and other lectures by Paul Bastide.","category":"page"},{"location":"examples/branching-oup/#Setting-up-the-problem","page":"Branching Ornstein-Uhlenbeck process","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"Similar to the branching Brownian motion tutorial, we cannot (yet) use the distributionally exact OUP implementation from the DiffEqNoiseProcess package, but must define the OUP as a SDEProblem:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using DifferentialEquations\nf(u,p,t) = p[2]*(p[1]-u)\ng(u,p,t) = p[3]\nu0 = 0.0\ntspan = (0.0, 5.0)\nμ = 2.0\nα = 5.0\nσ = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We can first verify that after an initial \"burn-in\" period, the OUP indeed fluctuates around its steady-state value mu:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using Plots\nsol = solve(oup, EM(), dt=0.01)\nplot(sol; linewidth=2, legend=false)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We can now set up the branching OUP problem in the same way as in the branching Brownian motion tutorial:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nboup = ConstantRateBranchingProblem(oup, λ, nchild)","category":"page"},{"location":"examples/branching-oup/#Sampling-a-trajectory","page":"Branching Ornstein-Uhlenbeck process","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"using Random\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01);\nplot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We observe that after a few generations, all cells fluctuate around their steady state value mu=20.","category":"page"},{"location":"examples/branching-oup/#Memory-in-the-branching-Ornstein-Uhlenbeck-process","page":"Branching Ornstein-Uhlenbeck process","title":"Memory in the branching Ornstein-Uhlenbeck process","text":"","category":"section"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"The dynamics of the branching OUP is driven by two parallel processes, the return to steady-state with rate alpha and the branching with rate lambda. If the half-life ln 2alpha of the stochastic fluctuations is short compared to the average lifetime 1lambda of a cell, each cell has sufficient time to equilibrate and the population as a whole will be distributed around the steady-state value, as in the figure above.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"However, if the half-life of the stochastic fluctuations is long compared to the average lifetime of a cell, large fluctuations early in the expansion can have a long-lasting effect on the population as a whole. This is the memory phenomenon referred to in the BranchingProcesses package introduction. For the branching OUP specifically, this phenomenon has been analyzed in great mathematical detail.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"To illustrate this phenomenon, we set the same random seed as above (to ensure exactly the same branching times) and only change the value of alpha:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"α = 0.5\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01)\nplot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"We observe that the system now did not have sufficient time to equilibrate within the typical life-time of a cell, and the population as a whole is shifted towards, that is, remembers, its initial state.","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"That the memory is due to the slow return to steady-state of the fluctuations and not the value of the initial state can be seen by starting the same problem in the steady state itself:","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"α = 0.5\nu0 = μ\noup = SDEProblem(f,g, u0, tspan, (μ, α, σ))\nboup = ConstantRateBranchingProblem(oup, λ, nchild)\nRandom.seed!(123)\nsol = solve(boup, EM(); dt=0.01)\nplot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/branching-oup/","page":"Branching Ornstein-Uhlenbeck process","title":"Branching Ornstein-Uhlenbeck process","text":"Again we observe a shifted distribution due to large fluctuations early in the expansion.","category":"page"},{"location":"examples/tree-reduction/#Tree-reduction","page":"Tree reduction","title":"Tree reduction","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"In experiments it is often the case that a single measurement (per variable) is obtained for a clone that is grown for set time or number of generations from a single cell. For instance in the MemorySeq paper, total RNA counts were obtained for each clone. In the BranchingProcesses package this can be easily simulated by applying a function to (for instance summing) the Values at the tips of a branching process. However in simulations we may want to do a bit more and obtain the entire time series of a summary statistic from a BranchingProcessSolution. This can be done with the reduce_tree function.","category":"page"},{"location":"examples/tree-reduction/#Setting-up-the-problem-and-sampling-a-tree","page":"Tree reduction","title":"Setting up the problem and sampling a tree","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"Start by creating a branching birth-death process. First define the single-cell process,","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"using Catalyst\nrn = @reaction_network begin\n    kp, 0 --> X\n    kd, X --> 0\nend\n\nusing DifferentialEquations, JumpProcesses\nu0 = [200]\ntspan = (0.0, 3.0)\np = [:kp => 50.0, :kd => 0.25]\njinput = JumpInputs(rn, u0, tspan, p)\njprob = JumpProblem(jinput)","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"and then the branching process,","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"using BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"Sample and plot a tree:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"using Random # hide\nRandom.seed!(123) # hide\nusing Plots, LaTeXStrings\nsol = solve(bjprob,  SSAStepper());\nplot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/tree-reduction/#Obtaining-a-reduced-time-series","page":"Tree reduction","title":"Obtaining a reduced time series","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"By default, reduce_tree sums the values of all cells alive at a given time, starting from the initial time of the root cell and stopping at the final time of the last living cell, with a time step of dt:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"sol_red = reduce_tree(sol; dt=0.01);","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"The reduced time series has the type ReducedBranchingProcessSolution and a plot recipe is available for this type:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"plot(sol_red)","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"It is possible to replace the default summing of values to taking a product, although use cases for this in practice may be rather limited:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"reduce_tree(sol; dt=0.01, reduction=\"prod\");","category":"page"},{"location":"examples/tree-reduction/#Applying-transformations","page":"Tree reduction","title":"Applying transformations","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"We can apply a transformation to the values of the process before summing. For instance, to sum the squared values:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"sol_red = reduce_tree(sol; dt=0.01, transform=(x -> x.^2));\nplot(sol_red)","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"or to count the number of cells alive at any given time:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"sol_red = reduce_tree(sol; dt=0.01, transform=(x -> 1));\nplot(sol_red)","category":"page"},{"location":"examples/tree-reduction/#Reducing-and-transforming-multivariable-processes","page":"Tree reduction","title":"Reducing and transforming multivariable processes","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"The default for reducing multivariable processes is to sum all variables separately. Let's recreate the multivariable branching process example:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"mm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\nu0 = [:S => 30, :E => 10, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)\nλ = 0.05\nnchild = 2\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);\nRandom.seed!(123) # hide\nsol = solve(bjprob,  SSAStepper());","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"Obtain a reduced time series for the sum of all variables:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"var_names = string.(unknowns(mm_system))\nsol_red = reduce_tree(sol; dt=0.1);\nplot(sol_red)","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"To summarize only one or a subset of variables, we can either use an idxs keyword argument:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"subs = [1,4]\nsol_red = reduce_tree(sol; dt=0.1, idxs=subs);\nplot(sol_red)","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"or use a transformation:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"sol_red = reduce_tree(sol; dt=0.1, transform=(x -> x[subs]));\nplot(sol_red);","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"Transformations can also be used to create summaries of summaries, for instance, for the total number of molecules:","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"sol_red = reduce_tree(sol; dt=0.1, transform=(x -> sum(x)));\nplot(sol_red)","category":"page"},{"location":"examples/tree-reduction/#Tree-reduction-and-ensemble-simulations","page":"Tree reduction","title":"Tree reduction and ensemble simulations","text":"","category":"section"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"Tree reduction is particularly useful in the context of ensemble simulations.","category":"page"},{"location":"examples/tree-reduction/","page":"Tree reduction","title":"Tree reduction","text":"ensemble_bjprob = EnsembleProblem(bjprob)\nensemble_tree = solve(ensemble_bjprob, SSAStepper(), EnsembleThreads(), trajectories=100)","category":"page"},{"location":"examples/branching-birth-death/#Branching-birth-death-processes","page":"Branching birth-death process","title":"Branching birth-death processes","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"In the branching Ornstein-Uhlenbeck process example, we considered the Ornstein-Uhlenbeck process (OUP) as a simple model for stochastically fluctuating gene expression. However, gene expression is modelled more realistically as a process taking discrete values representing molecule counts.","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"If we assume molecules are produced and degraded one at a time, we obtain a birth-death process. Such processes, and many other more complicated processes, are most easily defined using the Catalyst reaction network modelling language.","category":"page"},{"location":"examples/branching-birth-death/#Setting-up-the-problem","page":"Branching birth-death process","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"We first define the single-particle, in our case single-cell, dynamics as a reaction network:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Catalyst\nrn = @reaction_network begin\n    kp, 0 --> X\n    kd, X --> 0\nend","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"where kp and kd are the parameters of the model, respectively the production and degradation rates.","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"As explained in the Catalyst tutorials, we can define a JumpProcess to simulate this reaction network as follows:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using DifferentialEquations, JumpProcesses\nu0 = [200]\ntspan = (0.0, 3.0)\np = [:kp => 50.0, :kd => 0.25]\njinput = JumpInputs(rn, u0, tspan, p)\njprob = JumpProblem(jinput)","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"A trajectory for a single cell can be sampled and plotted:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"A branching jump problem is set up as in the branching Brownian motion and branching Ornstein-Uhlenbeck process examples:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using BranchingProcesses\nλ = 1.0         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/branching-birth-death/#Sampling-a-trajectory","page":"Branching birth-death process","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"To sample a tranjectory of the branching process, we call the solve function, resulting in a BranchingProcessSolution tree, that can be visualized using the standard plot function:","category":"page"},{"location":"examples/branching-birth-death/","page":"Branching birth-death process","title":"Branching birth-death process","text":"using Random # hide\nRandom.seed!(123) # hide\nsol = solve(bjprob,  SSAStepper());\nplot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(bp::T, alg::A; kwargs...) where {T<:ConstantRateBranchingProblem, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nSolve a branching stochastic process with constant branching rate defined by the ConstantRateBranchingProblem bp. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample trajectories of the underlying SDE problem.\n\nReturns a BranchingProcessSolution containing the problem definition and the resulting tree structure.\n\nSee also: ConstantRateBranchingProblem, solve_and_split_constantrate, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.solve_and_split_constantrate","page":"Solvers","title":"BranchingProcesses.solve_and_split_constantrate","text":"solve_and_split_constantrate(prob::T, λ::S, nchild::O, alg::A; kwargs...) where {T<:SciMLBase.AbstractDEProblem, S<:Real, O<:Union{Integer,DiscreteUnivariateDistribution}, A<:Union{SciMLBase.AbstractSciMLAlgorithm,Nothing}}\n\nRecursively solve a branching stochastic process where the single-particle dynamics is defined by the SDE problem prob, the branching rate is a constant λ, and the number of children nchild of each particle is either a non-negative integer or a discrete distribution from which the number of children is sampled. The positional argument alg and optional keyword arguments kwargs... are passed to the solver used to sample the trajectory of each particle.\n\nThe timespan of the problem prob defines the total time interval for the branching process. A lifetime for the first particle is sampled from an exponential distribution with rate λ. If the lifetime is larger than the total time interval, the problem is solved until the end of the original interval and a solution node is returned without children. If the lifetime is smaller than the total time interval, the problem is solved until the sampled lifetime, and a solution node is returned with recursively solved children for the remaining time interval.\n\nReturns a BranchingProcessNode representing the tree structure.\n\nSee also: SDE problems, sample_lifetime_constantrate, common solver options\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_lifetime_constantrate","page":"Solvers","title":"BranchingProcesses.sample_lifetime_constantrate","text":"sample_lifetime_constantrate(λ::T) where T <: Real\n\nSample the lifetime of a particle when the branching rate is a constant λ independent of time or the value of the process. This is equivalent to sampling from an exponential distribution with rate λ.\n\nNote that this is not the same as a ConstantRateJump where the rate is only constant between jumps.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.sample_offspring","page":"Solvers","title":"BranchingProcesses.sample_offspring","text":"sample_offspring(nchild::O) where O<:Union{Integer,DiscreteUnivariateDistribution}\n\nSample the number of offspring for a particle. If the input nchild is an integer, that integer is returned. If nchild is a discrete distribution, a sample from that distribution is returned.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.remake_initial_condition","page":"Solvers","title":"BranchingProcesses.remake_initial_condition","text":"remake_initial_condition(prob::P, tspan, u0=nothing) where P<:SciMLBase.AbstractDEProblem\n\nRemake the problem prob with a new timespan tspan and, optionally, a new initial condition u0. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#BranchingProcesses.get_timespan","page":"Solvers","title":"BranchingProcesses.get_timespan","text":"get_timespan(prob::P) where P<:SciMLBase.AbstractDEProblem\n\nGet the timespan of the problem prob. Works for SDEProblems and JumpProblems. Throws an error for NoiseProblems.\n\n\n\n\n\nget_timespan(tree::BranchingProcessSolution)\n\nGet the timespan of a BranchingProcessSolution tree, defined as the time from the initial time of the root to the latest final time of any of the leaves.\n\n\n\n\n\n","category":"function"},{"location":"examples/multi-variable-processes/#Multi-variable-branching-stochastic-processes","page":"Multi-variable branching processes","title":"Multi-variable branching stochastic processes","text":"","category":"section"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"The single-particle or single-cell stochastic process undergoing branching can be a multi-variable process. To illustrate this, consider the example of Michaelis-Menten enzyme kinetics, where an enzyme (E) transforms a substrate (S) into a product (P). The reaction network is defined in the Catalyst library of basic chemical reaction network models:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Catalyst\nmm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"We set up a single-cell process (with four variables, S. E. SE. and P) as in the model library:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using DifferentialEquations, JumpProcesses\nu0 = [:S => 30, :E => 10, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\n\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"A trajectory for a single cell can be sampled and plotted:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Plots\njsol = solve(jprob, SSAStepper())\nplot(jsol)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"A branching jump problem is set up as usual:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using BranchingProcesses\nλ = 0.05         # branching rate\nnchild = 2      # deterministic number of offspring\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"To sample a tranjectory of the branching process, we call the solve function as usual:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"using Random # hide\nRandom.seed!(123) # hide\nusing AbstractTrees\ntree = solve(bjprob,  SSAStepper());\ntreeheight(tree)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"If we plot the solution, by default the trajectory for the first variable is shown:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; branchpoints=true)","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"Because the plot recipe piggybacks on the plot recipe for differential equation solutions, variables for plotting can be chose in the same way:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; branchpoints=true, idxs=[2])","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"It is possible to plot multiple variables in the same plot, but since branching can result in many particles and line color is already used to distinguish different particles in the tree, this is not particularly illuminating:","category":"page"},{"location":"examples/multi-variable-processes/","page":"Multi-variable branching processes","title":"Multi-variable branching processes","text":"plot(tree; branchpoints=true, idxs=[1,2])","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#BranchingProcesses.tip_values","page":"Utilities","title":"BranchingProcesses.tip_values","text":"tip_values(tree::BranchingProcessSolution)\n\nReturn the values at the tips of a [BranchingProcessSolution](@docs) tree.\n\nSee also: nodevalue\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.reduce_tree","page":"Utilities","title":"BranchingProcesses.reduce_tree","text":"reduce_tree(tree::BranchingProcessSolution)\n\nReduce BranchingProcessSolution tree to an ordinary time series by combining the values of all particles alive at each time point. The timespan of the resulting time series is from the initial time of the root to the latest final time of any of the leaves of the input tree; the time points are spaced by dt (default: 0.01). The function transform (default: identity) is applied to the values of each particle before combining them. The function reduction (either \"sum\" (default) or \"prod\") is used to combine the (transformed) values of all particles alive at each time point.\n\nNote that if the resulting time series has different time points than the original trajectories in the input tree, the interpolating function of the solver used to sample the original trajectories is used to compute the reduced time series. Any keyword arguments kwargs... (for instance idxs=[1,3,5] to summarize only a subset variables) are passed to the interpolating function. \n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_transform","page":"Utilities","title":"BranchingProcesses.get_transform","text":"get_transform(sol::ReducedBranchingProcessSolution)\n\nGet the transformation function used in the reduction.\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_reduction_method","page":"Utilities","title":"BranchingProcesses.get_reduction_method","text":"get_reduction_method(sol::ReducedBranchingProcessSolution)\n\nGet the reduction method used to combine particle values.\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.get_original_solution","page":"Utilities","title":"BranchingProcesses.get_original_solution","text":"get_original_solution(sol::ReducedBranchingProcessSolution)\n\nGet the original BranchingProcessSolution that was reduced (if available).\n\n\n\n\n\n","category":"function"},{"location":"utils/#BranchingProcesses.has_original_solution","page":"Utilities","title":"BranchingProcesses.has_original_solution","text":"has_original_solution(sol::ReducedBranchingProcessSolution)\n\nCheck if the original BranchingProcessSolution is stored.\n\n\n\n\n\n","category":"function"},{"location":"examples/ensemble-simulation/#Ensemble-simulations","page":"Ensemble simulations","title":"Ensemble simulations","text":"","category":"section"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"In a Luria-Delbrück experiment, here called a fluctuation experiment, multiple clones are grown, each starting from a different single cell.","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"To simulate fluctuation experiments, the BranchingProcesses package supports SciML's parallel ensemble simulation methods.[1]","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"[1]: It would be more accurate to say that SciML is providing the support: because the BranchingProcesses package implements SciMLBase.solve, parallel ensemble simulations are supported out of the box.","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Let's model the actual Luria-Delbrück experiment as a birth-death process where a cell can switch from  wild-type to mutant, without any back-mutations:","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using DifferentialEquations, JumpProcesses, Catalyst\nrn = @reaction_network begin\n    μ, W --> M\nend\nu0 = [:W => 1, :M => 0]  # Always start in the wild-type state\np = [:μ => 0.01]  # Mutation rate\ntspan = (0.0, 10.0)\ndprob = DiscreteProblem(rn, u0, tspan, p)\njprob = JumpProblem(rn, dprob, Direct())","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Define a branching process problem:","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using BranchingProcesses\nλ = 1.0\nnchild = 2\nbjprob = ConstantRateBranchingProblem(jprob, λ, nchild);","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"To simulate a fluctuation experiment with 100 clones, first set up an EnsembleProblem:","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble_bjprob = EnsembleProblem(bjprob)","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Then solve the problem:","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble_sol = solve(ensemble_bjprob, SSAStepper(), EnsembleThreads(), trajectories=100)","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"We can obtain the number of cells and the number of mutants in each clone using the tip_values function:","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"cell_counts = [sum(tip_values(sol)) for sol in ensemble_sol];\ntotal_cell_counts = [sum(x) for x in cell_counts];\nmutant_cell_counts = [x[2] for x in cell_counts];","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using Plots\nhistogram(total_cell_counts,label=\"\",xlabel=\"Total cell counts\", ylabel=\"Number of clones\")","category":"page"},{"location":"examples/ensemble-simulation/","page":"Ensemble simulations","title":"Ensemble simulations","text":"histogram(mutant_cell_counts,label=\"\",xlabel=\"Mutant cell counts\", ylabel=\"Number of clones\")","category":"page"},{"location":"examples/branching-brownian-motion/#Branching-Brownian-motion","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Branching Brownian motion (BBM) is the simplest example of a branching stochastic process. The process starts with a \"root\" particle undergoing Brownian motion. After an exponentially distributed lifetime, the particle dies and gives rise to a number of offspring particles, each evolving independently by the same mechanisms, with initial position given by the final position of the parent particle.","category":"page"},{"location":"examples/branching-brownian-motion/#Setting-up-the-problem","page":"Branching Brownian motion","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In SciML, a \"problem\" is the encoding of a mathematical problem into a numerically computable form. A branching stochastic process problem is defined mathematically by three ingredients:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"a stochastic process defining the single-particle dynamics,\na branching rate,\na branching mechanism.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"For BBM, the single-particle dynamics is Brownian motion, or more precisely, the Wiener process. It is defined in a distributionally exact manner in the DiffEqNoiseProcess package, but for now the BranchingProcesses package only supports SDEProblem or JumpProblem types. Hence we define the Wiener process as the SDEProblem:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using DifferentialEquations\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The branching rate is a constant,","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"λ = 1.0","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"and the branching mechanism, for now, is taken as deterministic splitting into two particles,","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"nchild = 2","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The three ingredients defining BBM can now be packed in a ConstantRateBranchingProblem:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using BranchingProcesses\nbbm = ConstantRateBranchingProblem(bm, λ, nchild)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"BranchingProcesses does not yet support branching with non-constant, that is, time and/or state-dependent branching rates.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"note: Timespan of the branching process\nBy convention it is assumed that the timespan argument tspan used to define the single-particle dynamics problem is the requested timespan of the entire branching process. In other words, the branching process bbm will be simulated for the timespan:bbm.prob.tspan","category":"page"},{"location":"examples/branching-brownian-motion/#Sampling-a-trajectory","page":"Branching Brownian motion","title":"Sampling a trajectory","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In SciML, sampling a trajectory of a stochastic process is done by solving the problem. BranchingProcesses follows this convention, and hence we can run:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Random # hide\nRandom.seed!(123) # hide\nsol = solve(bbm, EM(); dt=0.01);","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The (optional) second argument in the solve function specifies the algorithm used to simulate the single-particle dynamics, see the SDE solvers page for a full list of available algorithms. Any optional keyword arguments are also directly passed to the chosen single-particle simulation algorithm.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The output of solve is a BranchingProcessSolution, a tree structure where each node contains the solution (simulated trajector) of a particle in the branching process trajectory, as well as pointers to the solutions of its children.","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"A plot recipe is included in the BranchingProcesses package to plot the sampled trajectory using the standard plot command, which accepts the usual attributes for a series of type \"path\":","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Plots\nplot(sol; linewidth=2)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Optionally, the branchpoints (birth times and values of each particle) can be included in the plot:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"plot(sol; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The size, shape, color, etc. of the branchpoint markers can be changed using the usual attributes","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The plot recipe for a BranchingProcessSolution calls another recipe for a BranchingProcessNode on the solution's root node sol.tree. Hence we can plot any subtree of the solution by plotting a specific node, for instance:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"plot(sol.tree.children[1].children[1]; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/branching-brownian-motion/#Non-deterministic-offspring-distribution","page":"Branching Brownian motion","title":"Non-deterministic offspring distribution","text":"","category":"section"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"In the setup above, each particle gives rise to two offspring particles at the end of its lifetime, resulting in an exponential increase in the number of particles over time. Non-deterministic offspring distributions are also supported. For instance, in a cell division model, we can assume that cells divide (2 offspring), enter or remain is a quiescent, non-dividing state (1 offspring, itself), or die (0 offpsring), each with some probability. In such a scenario, we define the number of children nchild as a univariate discrete distribution:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"using Distributions\nnchild2 = DiscreteNonParametric([0, 1, 2], [0.2, 0.5, 0.3])","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"The branching process problem is constructed, solved, and plotted as before:","category":"page"},{"location":"examples/branching-brownian-motion/","page":"Branching Brownian motion","title":"Branching Brownian motion","text":"Random.seed!(15) # hide\nbbm2 = ConstantRateBranchingProblem(bm, λ, nchild2)\nsol2 = solve(bbm2, EM(); dt=0.01);\nplot(sol2; linewidth=2, branchpoints=true)","category":"page"},{"location":"examples/abstracttrees-interface/#AbstractTrees-interface","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"A BranchingProcessSolution is an AbstractTrees instance in which each node is represented by an AbstractSciMLSolution. Hence useful statistics of the sampled branching process trajectory can be obtained by combining features of these two types.","category":"page"},{"location":"examples/abstracttrees-interface/#Tree-statistics","page":"AbstractTrees interface","title":"Tree statistics","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Useful tree statistics can be obtained directly from the AbstractTrees interface. To illustrate this, consider the example of branching Brownian motion:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"using DifferentialEquations, BranchingProcesses\nf(u,p,t) = 0.0\ng(u,p,t) = 1.0\nu0 = 0.0\ntspan = (0.0, 5.0)\nbm = SDEProblem(f,g, u0, tspan)\nλ = 1.0\nnchild = 2\nbbm = ConstantRateBranchingProblem(bm, λ, nchild)\nusing Random # hide\nRandom.seed!(123) # hide\nsol = solve(bbm, EM(); dt=0.01)","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"The number of particles alive at the end of the sampled trajectory is:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"using AbstractTrees\nnum_alive = treebreadth(sol)","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"The longest lineage in the tree is:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"max_lineage_length = treeheight(sol)","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Note that the actual tree structure implementing the AbstractTrees interface is the field sol.tree of type BranchingProcessNode. When tree operations like the ones above are called on a BranchingProcessSolution, they are delegated to the tree field. Hence we can call the same operations on any instance of aBranchingProcessNode, for instance","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"num_alive_sub = treebreadth(sol.tree.children[1])","category":"page"},{"location":"examples/abstracttrees-interface/#Values-at-the-tips-of-a-branching-process","page":"AbstractTrees interface","title":"Values at the tips of a branching process","text":"","category":"section"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"We are often interested in the values at the tips of a branching process, that is, the values at the final time T of a branching experiment of the particles alive at that time. To obtain these values, we use an iterator over the leaves of the tree and use the array interface for SciMLSolutions:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"tip_vals = [node.sol[end] for node in Leaves(sol)] ","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Again the call Leaves(sol) is delegated to its tree field, that is, it is equivalent to Leaves(sol.tree).","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"Because it is common to need the final value of a particle, this has been implemented as the value associated with a node:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"tip_vals == [nodevalue(node) for node in Leaves(sol)] ","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"An even shorter short-cut is to call the function tip_values:","category":"page"},{"location":"examples/abstracttrees-interface/","page":"AbstractTrees interface","title":"AbstractTrees interface","text":"tip_vals = tip_values(sol)","category":"page"},{"location":"#BranchingProcesses.jl","page":"Introduction","title":"BranchingProcesses.jl","text":"","category":"section"},{"location":"#BranchingProcesses.BranchingProcesses","page":"Introduction","title":"BranchingProcesses.BranchingProcesses","text":"Exports\n\nBranchingProcessNode\nBranchingProcessSolution\nConstantRateBranchingProblem\nReducedBranchingProcessSolution\nget_timespan\nreduce_tree\nremake_initial_condition\nsample_lifetime_constantrate\nsample_offspring\nsolve\nsolve_and_split_constantrate\ntip_values\n\nImports\n\nAbstractTrees\nBase\nDistributions\nDocStringExtensions\nRecipesBase\nSciMLBase\n\nBranchingProcesses\n\n(Image: Dev) (Image: Build Status)\n\nBranchingProcesses is a Julia package for modelling branching stochastic processes, also known as branching particle systems. \n\nBranching stochastic processes are processes where \"particles\" (which could represent cells, individuals, or species depending on the context) have one or more degrees of freedom X(t) whose dynamics is described by a stationary Markov process. After a certain lifetime, a particle splits into kgeq 0 identical, independent offspring particles with probability p_k. This process is repeated indefinitely, producing a collection of N(t) particles at time t. Splitting happens with a rate function gamma(xtau) that may depend on the current state x and age tau of the particle.\n\nExamples of such processes are:\n\nClassical branching processes, which correspond to the case X(t)equiv 1.\nBranching Brownian motion\nBranching Ornstein-Uhlenbeck processes used in phylogenetic comparative methods\n\nAlthough the package can probably be used or extended for generic phylodynamic analyses, the dedicated PhyloTraits package will probably be more appropriate for that purpose.\n\nThe primary motivation for this package is to provide a framework for the analysis of a \"memory\" phenomenon that can occur in branching stochastic processes if the relaxation rate of the single-particle dynamics is slow relative to the branching rate. In this case the system can remember its initial state, or, put differently, large fluctuations early in the expansion can have a long-lasting effect on the state of the system. The study of this phenomenon implicitly traces its roots (no pun intended) to Luria and Delbrück's fluctuation analysis. More recently, it has been\n\nstudied mathematically in branching Ornstein-Uhlenbeck processes,\nobserved experimentally in proliferating cancer cell populations\nproposed as an important property of proliferating active matter\n\nStudying this phenomenon requires the analysis of fluctuations across multiple independent realizations of the branching process. This is in contrast to the more common use of branching processes in population and phylogenetics, where the focus is on the evolution of a single lineage.\n\nSupported stochastic processes\n\nThe aim is to support any process that can be implemented as a stochastic differential equation, jump process, or jump diffusion equation. \n\nSpecific branching process constructors will be implemented for the following stochastic processes:\n\nBrownian motion\nOrnstein-Uhlenbeck process\nBirth-death process\nThe stochastic gene expression models of Gorin et al (2022)\n\nFor now, see the examples in the documentation for how to construct branching processes.\n\nSupported rate function\n\nAny valid constant or variable rate function. The default is a constant rate function with parameter 1, that is, the probability for a particle to be alive with lifetime tau is exp(-tau).\n\nSupported splitting distributions\n\nAny discrete univariate distribution (default: Dirac with parameter 2, that is, all particles split into two offspring particles).\n\n\n\n\n\n","category":"module"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Problem-types","page":"Types","title":"Problem types","text":"","category":"section"},{"location":"types/#BranchingProcesses.ConstantRateBranchingProblem","page":"Types","title":"BranchingProcesses.ConstantRateBranchingProblem","text":"struct ConstantRateBranchingProblem{P<:SciMLBase.AbstractDEProblem, R<:Real, O<:Union{Integer, DiscreteUnivariateDistribution, UnivariateDistribution{Discrete}, DiscreteDistribution{Univariate}}} <: BranchingProcesses.BranchingProblem\n\nA structure to define a branching stochastic process with constant branching rate.\n\nFields\n\nprob: The SDE or jump process problem defining the single-particle dynamics of the branching process, an instance of SciMLBase.AbstractSDEProblem or SciMLBase.AbstractJumpProblem.\nbranchrate: The branching rate of the process, which must be a positive real number.\nnchild: The number of children to be created for each particle, which can be a non-negative integer or a discrete distribution with non-negative support from which the number of children is sampled.\n\n\n\n\n\n","category":"type"},{"location":"types/#Solution-types","page":"Types","title":"Solution types","text":"","category":"section"},{"location":"types/#BranchingProcesses.BranchingProcessSolution","page":"Types","title":"BranchingProcesses.BranchingProcessSolution","text":"struct BranchingProcessSolution{P<:BranchingProcesses.BranchingProblem, T<:Union{DESolution, SciMLSolution}}\n\nA complete solution of a branching stochastic process, containing both the problem definition and the resulting tree structure.\n\nFields\n\nprob: The branching problem that was solved.\ntree: The root node of the solution tree.\nalg: Algorithm used to solve the problem (optional).\nretcode: Return code indicating success/failure.\nstats: Additional statistics or metadata (optional).\n\n\n\n\n\n","category":"type"},{"location":"types/#BranchingProcesses.BranchingProcessNode","page":"Types","title":"BranchingProcesses.BranchingProcessNode","text":"struct BranchingProcessNode{T<:Union{DESolution, SciMLSolution}}\n\nA tree node structure to hold individual particle solutions in a branching process.\n\nFields\n\nsol: The solution of the particle associated to this node.\nchildren: A vector of child nodes representing offspring particles.\n\n\n\n\n\n","category":"type"},{"location":"types/#AbstractTrees.children","page":"Types","title":"AbstractTrees.children","text":"AbstractTrees.children(node::BranchingProcessNode)\n\nReturn the children of a BranchingProcessNode.\n\n\n\n\n\n","category":"function"},{"location":"types/#AbstractTrees.nodevalue","page":"Types","title":"AbstractTrees.nodevalue","text":"AbstractTrees.nodevalue(node::BranchingProcessNode)\n\nReturn the value of a BranchingProcessNode, defined as its final state value.\n\n\n\n\n\n","category":"function"},{"location":"types/#BranchingProcesses.ReducedBranchingProcessSolution","page":"Types","title":"BranchingProcesses.ReducedBranchingProcessSolution","text":"struct ReducedBranchingProcessSolution{T, N, uType, tType, P, A, IType, TransType, RedType, OrigType} <: SciMLBase.AbstractTimeseriesSolution{T, N, uType}\n\nA solution type for the output of reduce_tree. Contains the reduced time series from a branching process tree where values of all particles alive at each time point have been combined using a reduction function.\n\nFields\n\nu: The reduced values at each time point.\nt: The time points.\nprob: The original branching problem (optional).\nalg: Algorithm information (optional).\ndense: Whether dense output is available.\ninterp: Interpolation object.\ntslocation: Time series location.\nretcode: Return code.\ntransform: Transformation function applied to particle values before reduction.\nreduction: Reduction method used to combine particle values (\"sum\", \"prod\", or custom function).\noriginal_solution: Original BranchingProcessSolution that was reduced (optional).\n\n\n\n\n\n","category":"type"}]
}
